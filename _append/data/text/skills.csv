Name,Description,Script
Whoopie Cushion,Fart.ogg,sfx(~_fart~);
Lock Advocate,Lock [lock]1 dice,inflict(~lock~[;]1); sfx(~_lock~);
Final Countdown,Reduce countdowns by 5,boostcountdowns(5);
Midnight Snake,Roll a [dice]6 and a [dice]1,givedice([6[;] 1]);
Prickly Pear,Gain [thorns]2 thorns,inflictself(~thorns~[;]2); sfx(~_thorns~);
Curseathon,[75%][curse]2 to enemy[;] [curse] to self next turn,inflictself(~cursenext~[;]1); inflict(~curse~[;]2); sfx(~_curse~);
Sniper Shot,[90%]Reduce enemy health by [heart]5,pierceattack(5); sfx(~_plasma~);
Melting Ice,[95%]Inflict [fire]1 and [ice]1,inflict(~fire~); inflict(~ice~); sfx(~_fire~); sfx(~_ice~);
Bonus Payout,Use an extra jackpot ability[;] increase jackpot range,self.roll_jackpotbonus += 1; if(!self.roll_error){ self.roll_range += 1; adjustrobotcounter(0); } sfx(~stealgold~); for(eq in self.equipment){ if(eq.name == ~Insider Info~){ if((self.roll_total + eq.getvar(~diceval~)) >= (self.roll_target - self.roll_range) && !self.roll_jackpot && !self.roll_error){ if((self.roll_total + eq.getvar(~diceval~)) > self.roll_target){ eq.fulldescription = ~The next dice you[newline]calculate will be a [red]~ + eq.getvar(~diceval~); } else{ eq.fulldescription = ~The next dice you[newline]calculate will be a [yellow]~ + eq.getvar(~diceval~); } } else{ eq.fulldescription = ~The next dice you[newline]calculate will be a ~ + eq.getvar(~diceval~); } for(x in self.status){ if(x.name == ~Blind~ && x.value >= e.getvar(~calculatepressed~)){ e.fulldescription = ~The next dice you[newline]calculate will be a [blind]???~; }  if(x.type == ~ice~ && x.value >= e.getvar(~calculatepressed~)) { e.fulldescription = ~The next dice you[newline]calculate will be a [ice]1~; }  if(x.type == ~ice_all~) { e.fulldescription = ~The next dice you[newline]calculate will be a [ice]1~; } } } }
Firey Roll,Roll 2 burning dice,givedice([rand([1[;]2[;]3[;]4[;]5[;]6])[;]rand([1[;]2[;]3[;]4[;]5[;]6])]); self.dicepool[self.dicepool.length - 1].burnnow(); self.dicepool[self.dicepool.length - 2].burnnow(); sfx(~_fire~);
Double Roll,Roll 2 dice,givedice([rand([1[;]2[;]3[;]4[;]5[;]6])[;]rand([1[;]2[;]3[;]4[;]5[;]6])]);
Faulty Wiring,Inflict [shock]2 shock,inflict(~shock~[;]2); sfx(~_shock~);
Icy Roll,Roll two [dice]1s,givedice([1[;]1]);
Syringe,Drain [heart]3 health,drain(3); sfx(~_drain~);
Slingshot,Do [sword]5 damage,attack(5); sfxdamage(5);
Suit Up,Gain [reduce]1 reduce,inflictself(~reduce~[;] 1); sfx(~_shield~);
Slippery Shoes,Gain [dodge]1 dodge,inflictself(~dodge~); sfx(~_dodge~);
Salvaging,[95%]Re-use next equipment,inflictself(REEQUIPNEXT); sfx(~_recycle~);
Uninnate,[90%]Remove the Enemy's Innate,/*storedprizeimmune*/ removestatus(~vampire~); removestatus(~jayinnate~); removestatus(~losegoldinnate~); target.innate = []; sfx(~_thinghappens~); screenshake();
Lucky Roll,Roll a [dice]7,givedice([7]);
Perfect Spanner,[90%]Combine all dice into one,/*storedprizeimmune*/ var dicenumber = 0; var isblinded = false; for(mydice in self.dicepool){ if(mydice.available()){ dicenumber += mydice.basevalue + mydice.modifier; mydice.removedice(); if(mydice.blind){ isblinded = true; } } } if(dicenumber != 0){ givedice([dicenumber]); self.dicepool[self.dicepool.length - 1].blind = isblinded; }
Fifths Roll,[80%]Increase jackpot range next turn,inflictself(~jackpotrangeup~);
Timebomb,[95%]Do [fire]15 damage in 3 turns,jinx(~Timebomb~[;]~take [fire]15 damage~[;]~Take [fire]15 damage~[;]~attack(15[;] FIRE); sfx(\~_fire\~);~[;] target[;] self[;] 3[;] d); sfx(~_shock~);
Cthulhu's Shield,[90%]Gain [shield]4 shield and [thorns]2 thorns,inflictself(~shield~[;]4); inflictself(~thorns~[;]2); sfx(~_shield~); sfx(~_thorns~);
Ctrl + C,[95%]Copy one of your equipment,/*storedprizeimmune*/ var ownequipment = []; for (eq in self.equipment){ if(!eq.hastag(~cannotsteal~) && !eq.hastag(~nojackpotcopy~) && eq.ready){ ownequipment.push(eq); } } if(ownequipment.length > 0){ var randomequipment = rand(ownequipment); giveequipment(randomequipment.name + randomequipment.namemodifier); } sfx(~_thinghappens~);
Nanomachines,Gain [reduce]2 reduce,inflictself(~reduce~[;] 2); sfx(~_shield~);
Stress,Inflict [weaken]1 weaken,inflict(WEAKEN); sfx(~_weaken~);
Lifeblood,Heal [heal]5 health,attackself(-5); sfx(~_heal~);
Ripper Mode,[80%]Next turn[;] deal [sword]2 extra damage,inflictself(~rippermodefail~[;] 2);
Blood Arrow,[80%]Lose [heart]3 health[;] do [sword]10 damage,self.hp -= 3; sfx(~_drain~); attack(10); sfxdamage(10);
Persona,Gain [fury]1 fury,inflictself(~fury~); sfx(~_fury~);
Ice Age,Freeze [ice]2 dice,inflict(~ice~[;] 2); sfx(~_ice~);
Leech,Drain [heart]5 health,drain(5); sfx(~_drain~);
Dragon's Roll,Roll a [dice]10,givedice([10]);
Flamethrower,Do [fire]6 damage,attack(6[;] FIRE); sfx(~_fire~);
Basil's Protection,Gain [thorns]1 thorns and heal [heal]2,inflictself(~thorns~[;]1); sfx(~_thorns~); attackself(-2); sfx(~_heal~);
Prince's Steal,[80%]Borrow equipment and upgrade it,/*storedprizeimmune*/ var enemyequipment = []; for (eq in target.equipment){ if(!eq.hastag(~cannotsteal~)){ enemyequipment.push(eq); } } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); giveequipment(randomequipment.name + randomequipment.namemodifier + ~+~); }
Containment Wave,[80%]Lock a random Enemy equipment,if(target != null) { var enemyequipment = []; for (eq in target.equipment){ if(!eq.hastag(~cannotsteal~) && eq.availablenextturn){ enemyequipment.push(eq); } } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); randomequipment.availablenextturn = false; randomequipment.unavailabletext = ~Locked!~; randomequipment.unavailabledetails = [~Locked until~[;]~next turn.~]; enemyequipment.remove(randomequipment); } } sfx(~_lock~);
Sandvich,Heal [heal]3 health,attackself(-3); sfx(~_heal~);
Mad Dog's Howl,Inflict [weaken]3 weaken,inflict(~weaken~[;]3); sfx(~_weaken~);
Tri Attack,[95%]Inflict [fire]1[;] [ice]1 and [shock]1,inflict(FIRE); inflict(ICE); inflict(SHOCK); sfx(~_fire~); sfx(~_ice~); sfx(~_shock~);
Run It Back,Start a new turn,inflictself(EXTRATURN); sfx(~_fury~); self.endturnnow();
Limit Break,[70%]Set an equipment to normal slots only,var unlimitcards = []; var unlimitslots = []; if(self.getvar(~unlimitcards~) != null){ if(self.getvar(~unlimitcards~).length > 0){ unlimitcards = unlimitcards.concat(self.getvar(~unlimitcards~)); unlimitslots = unlimitslots.concat(self.getvar(~unlimitslots~)); } } for (i in 0...1) { var selfequipment = []; for (eq in self.equipment) { if (eq.slots.indexOf(~COUNTDOWN~) < 0 && eq.slots.length > 0 && eq.ready && eq.hastag(~skillcard~) == false) { var normalslotamount = 0; var extraslots = 0; for (slot in eq.getslots()) { if (slot == ~NORMAL~){ normalslotamount++; } if (slot.indexOf(~FREE~) > -1 # slot.indexOf(~SPARE~) > -1){ extraslots++; } } if ((normalslotamount + extraslots) < eq.slots.length) selfequipment.push(eq); } } if (selfequipment.length > 0) { var limitbreakcard = rand(selfequipment); unlimitcards.push(limitbreakcard); unlimitslots.push(limitbreakcard.slots); self.setvar(~unlimitcards~[;] unlimitcards); self.setvar(~unlimitslots~[;] unlimitslots); var newslots = []; for (k in limitbreakcard.getslots()) { if (k.indexOf(~FREE~) != -1 # k.indexOf(~SPARE~) != -1) newslots.push(i); else { newslots.push(~NORMAL~); } { limitbreakcard.changeslots(newslots); limitbreakcard.animate(~slotschanged~); sfx(~_thinghappens~); } if (selfequipment.length == 0) { self.textparticle(~No equipment!~); } } } }
Dead Ringer,[90%]Survive one fatal blow this turn,inflictself(~survive~); sfx(~_fury~); inflictself(~survivenomorehehe~);
Reshuffle,Reroll jackpot options,/*storedprizeimmune*/ runscript(~jackpotofalltrades/resetjackpot~[;] []); self.roll_jackpotbonus += 1; self.getskillcard().skillsavailable[self.getskillcard().skills.indexOf(~Reshuffle~)] = true; sfx('jackpot_reducecounter');
Debatable Damage,[90%]Randomly do [sword]1-10 damage,var damage = rand([for(i in 1...11) i]); attack(damage); sfxdamage(damage);
Stars And Time,[75%]Revert [heart] to last turn ([heart]<var:previousroundplayerhp>),/*storedprizeimmune*/ if(self.getvar(~previousroundplayerhp~) != 0){ self.hp = self.getvar(~previousroundplayerhp~); } sfx(~_loop~);
Borrow,Borrow equipment,/* Use this instead of the usual Steal skill[;] this one doesn't get disabled if the player is holding a full inventory already. */ /*storedprizeimmune*/ var enemyequipment = []; for (eq in target.equipment){ if(!eq.hastag(~cannotsteal~)){ enemyequipment.push(eq); } } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); giveequipment(randomequipment.name + randomequipment.namemodifier); }
Used Syringe,[75%]Inflict a random bad status effect,var NegativeStatusList = [~ice~[;] ~ice_all~[;] ~fire~[;] ~fire_all~[;] ~shock~[;] ~silence~[;] ~blind~[;] ~poison~[;] ~lock~[;] ~curse~[;] ~confuse~]; var additionalStatuses = [~reuseblock~[;] ~bluescorch~[;] ~smorify~[;] ~weaken@p~[;] ~staticshock~]; for(i in 0...NegativeStatusList.length){ additionalStatuses.push(~alternate_~ + NegativeStatusList[i]); }  additionalStatuses.push(~counter_~ + rand([1[;]2[;]3[;]4[;]5[;]6])); additionalStatuses.push(~dice_trigger_~ + rand([1[;]2[;]3[;]4[;]5[;]6])); NegativeStatusList.push(~vanish~); var pickedStatus = rand(NegativeStatusList.concat(additionalStatuses)); inflict(pickedStatus); if(NegativeStatusList.indexOf(pickedStatus) != -1) sfx(~_~ + s); else sfx(~_weaken~);
Botulinum Dose,[65%]Inflict every single negative status effect,var NegativeStatusList = [~ice~[;] ~ice_all~[;] ~fire~[;] ~fire_all~[;] ~shock~[;] ~silence~[;] ~blind~[;] ~poison~[;] ~lock~[;] ~curse~[;] ~confuse~]; for(i in 0...NegativeStatusList.length){ NegativeStatusList.push(~alternate_~ + NegativeStatusList[i]); }  NegativeStatusList.push(~counter_~ + rand([1[;]2[;]3[;]4[;]5[;]6])); NegativeStatusList.push(~dice_trigger_~ + rand([1[;]2[;]3[;]4[;]5[;]6])); NegativeStatusList.push(~vanish~); for(s in NegativeStatusList){ inflict(s[;] 2); sfx(~_~ + s); } var additionalstatuses = [~reuseblock~[;] ~bluescorch~[;] ~smorify~[;] ~weaken@p~[;] ~staticshock~]; for(s in additionalstatuses){ inflict(s[;] 2); }
Jimbo's Trick,x1.5 mult all your dice,var extradice = []; if(self.dicepool != null) { if (self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ extradice.push(mydice.basevalue + mydice.modifier); mydice.basevalue = (mydice.basevalue + mydice.modifier) * 1.5; mydice.modifier = 0; var newanimation = new elements.Animation(); newanimation.applytodice(mydice); mydice.animation.push(newanimation); newanimation.addcommand(~textparticle~[;] ~[red]x1.5![]~[;] 0xFFFFFF); } } sfx(~_xmult~); sfx(~_xmult~); } }
Ka... Ching!,[90%]Gain [star]1 Guaranteed Autoroll,inflictself(~manualroll~[;] 1); sfx(~stealgold~);
Stored Prize,[90%]Next jackpot skill goes twice,/*storedprizeimmune*/ inflictself(~storedprize~[;] 1); sfx(~stealgold~);
Split Path,[80%]Trigger adjacent jackpot skills,/*storedprizeimmune*/ var storedSkillIndex = -1; for(j in 0...3){ if(j != 1){ if(self.getskillcard().skills[j].name.indexOf(~Reshuffle~) != -1){ storedSkillIndex = j; continue; } else{ if(self.getskillcard().skillsavailable[j]){ self.getskillcard().skills[j].execute(self[;] target); self.getskillcard().skillsavailable[j] = false; } } } else{ self.getskillcard().skillsavailable[j] = true; } }  if(storedSkillIndex != -1){ self.getskillcard().skills[storedSkillIndex].execute(self[;] target); }
Basil's Protection+,Gain [thorns][yellow]2[] thorns and heal [heal][yellow]3[],inflictself(~thorns~[;]2); sfx(~_thorns~); attackself(-3); sfx(~_heal~);
Blood Arrow+,[80%]Lose [heart][yellow]1[] health[;] do [sword]10 damage,self.hp -= 1; sfx(~_drain~); attack(10); sfxdamage(10);
Bonus Payout+,Use an extra Jackpot ability[;] increase Jackpot range [yellow]by 2[],self.roll_jackpotbonus += 1; if(!self.roll_error){ self.roll_range += 2; adjustrobotcounter(0); } sfx(~stealgold~); for(eq in self.equipment){ if(eq.name == ~Insider Info~){ if((self.roll_total + eq.getvar(~diceval~)) >= (self.roll_target - self.roll_range) && !self.roll_jackpot && !self.roll_error){ if((self.roll_total + eq.getvar(~diceval~)) > self.roll_target){ eq.fulldescription = ~The next dice you[newline]calculate will be a [red]~ + eq.getvar(~diceval~); } else{ eq.fulldescription = ~The next dice you[newline]calculate will be a [yellow]~ + eq.getvar(~diceval~); } } else{ eq.fulldescription = ~The next dice you[newline]calculate will be a ~ + eq.getvar(~diceval~); } for(x in self.status){ if(x.type == ~ice~ && x.value >= e.getvar(~calculatepressed~)){ e.fulldescription = ~The next dice you[newline]calculate will be a [ice]1~; } if(x.type == ~ice_all~){ e.fulldescription = ~The next dice you[newline]calculate will be a [ice]1~; } if(x.name == ~Blind~ && x.value >= e.getvar(~calculatepressed~)){ e.fulldescription = ~The next dice you[newline]calculate will be a [blind]???~; } } } }
Borrow+,Borrow[yellow](?)[] equipment,/*storedprizeimmune*/ var enemyequipment = []; for (eq in target.equipment){ if(!eq.hastag(~cannotsteal~)){ enemyequipment.push(eq); } } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); randomequipment.availablenextturn = false; randomequipment.unavailabletext = ~Borrowed!~; randomequipment.unavailabledetails = [~\~Borrowed\~ until~[;]~next turn.~]; giveequipment(randomequipment.name + randomequipment.namemodifier); }
Botulinum Dose+,[60%]Inflict every single negative status effect [yellow]x2[],var NegativeStatusList = [~ice~[;] ~ice_all~[;] ~fire~[;] ~fire_all~[;] ~shock~[;] ~silence~[;] ~blind~[;] ~poison~[;] ~lock~[;] ~curse~[;] ~confuse~]; for(i in 0...NegativeStatusList.length){ NegativeStatusList.push(~alternate_~ + NegativeStatusList[i]); }  NegativeStatusList.push(~counter_~ + rand([1[;]2[;]3[;]4[;]5[;]6])); NegativeStatusList.push(~dice_trigger_~ + rand([1[;]2[;]3[;]4[;]5[;]6])); NegativeStatusList.push(~vanish~); for(s in NegativeStatusList){ inflict(s[;] 2); sfx(~_~ + s); } var additionalstatuses = [~reuseblock~[;] ~bluescorch~[;] ~smorify~[;] ~weaken@p~[;] ~staticshock~]; for(s in additionalstatuses){ inflict(s[;] 2); }
Cthulhu's Shield+,[90%]Gain [shield][yellow]5[] shield and [thorns][yellow]3[] thorns,inflictself(~shield~[;]5); inflictself(~thorns~[;]3); sfx(~_shield~); sfx(~_thorns~);
Curseathon+,[yellow][curse]2 to enemy[],inflict(~curse~[;]2); sfx(~_curse~);
Ctrl + C+,[70%]Copy [yellow]+ upgrade[] one of your equipment,/*storedprizeimmune*/ var ownequipment = []; for (eq in self.equipment){ if(!eq.hastag(~cannotsteal~) && !eq.hastag(~nojackpotcopy~) && eq.ready){ ownequipment.push(eq); } } if(ownequipment.length > 0){ var randomequipment = rand(ownequipment); giveequipment(randomequipment.name + ~+~); } sfx(~_thinghappens~);
Dead Ringer+,[70%]Survive 1 fatal blow this [yellow]and next[] turn,inflictself(~survive~); inflictself(~survivenextturn~); sfx(~_fury~); inflictself(~survivenomorehehe~);
Debatable Damage+,[90%]Randomly do [sword][yellow]5[]-10 damage,var damage = rand([for(i in 6...11) i]); attack(damage); sfxdamage(damage);
Double Roll+,Roll 2 dice [yellow]higher than 2[],givedice([rand([3[;]4[;]5[;]6])[;]rand([3[;]4[;]5[;]6])]);
Dragon's Roll+,Roll a [dice][yellow]12[],givedice([12]);
Faulty Wiring+,Inflict [shock][yellow]3[] shock,inflict(~shock~[;]3); sfx(~_shock~);
Fifths Roll+,[70%]Increase jackpot range [yellow]by 2[] next turn,inflictself(~jackpotrangeup~[;] 2);
Final Countdown+,Reduce countdowns by [yellow]8[],boostcountdowns(8);
Firey Roll+,Roll [yellow]3[] burning dice,givedice([rand([1[;]2[;]3[;]4[;]5[;]6])[;]rand([1[;]2[;]3[;]4[;]5[;]6])[;]rand([1[;]2[;]3[;]4[;]5[;]6])]); for(i in 1...4){ self.dicepool[self.dicepool.length - i].burnnow(); } sfx(~_fire~);
Flamethrower+,Do [fire][yellow]8[] damage,attack(8[;] FIRE); sfx(~_fire~);
Icy Roll+,Roll [yellow]three[] [dice]1s,givedice([1[;]1[;]1]);
Jimbo's Trick+,[yellow]x2[] mult all your dice,var extradice = []; if(self.dicepool != null) { if (self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ extradice.push(mydice.basevalue + mydice.modifier); mydice.basevalue = (mydice.basevalue + mydice.modifier) * 2; mydice.modifier = 0; var newanimation = new elements.Animation(); newanimation.applytodice(mydice); mydice.animation.push(newanimation); newanimation.addcommand(~textparticle~[;] ~[red]x2![]~[;] 0xFFFFFF); } } sfx(~_xmult~); sfx(~_xmult~); } }
Ka... Ching!+,[90%]Gain [star][yellow]2[] Guaranteed Autoroll,inflictself(~manualroll~[;] 2); sfx(~stealgold~);
Leech+,Drain [heart][yellow]7[] health,drain(7); sfx(~_drain~);
Lifeblood+,Heal [heal][yellow]7[] health,attackself(-7); sfx(~_heal~);
Limit Break+,[70%]Set [yellow]2[] equipment to normal slots only,var unlimitcards = []; var unlimitslots = []; if(self.getvar(~unlimitcards~) != null){ if(self.getvar(~unlimitcards~).length > 0){ unlimitcards = unlimitcards.concat(self.getvar(~unlimitcards~)); unlimitslots = unlimitslots.concat(self.getvar(~unlimitslots~)); } } for (i in 0...2) { var selfequipment = []; for (eq in self.equipment) { if (eq.slots.indexOf(~COUNTDOWN~) < 0 && eq.slots.length > 0 && eq.ready && eq.hastag(~skillcard~) == false) { var normalslotamount = 0; var extraslots = 0; for (slot in eq.getslots()) { if (slot == ~NORMAL~){ normalslotamount++; } if (slot.indexOf(~FREE~) > -1 # slot.indexOf(~SPARE~) > -1){ extraslots++; } } if ((normalslotamount + extraslots) < eq.slots.length) selfequipment.push(eq); } } if (selfequipment.length > 0) { var limitbreakcard = rand(selfequipment); unlimitcards.push(limitbreakcard); unlimitslots.push(limitbreakcard.slots); self.setvar(~unlimitcards~[;] unlimitcards); self.setvar(~unlimitslots~[;] unlimitslots); var newslots = []; for (k in limitbreakcard.getslots()) { if (k.indexOf(~FREE~) != -1 # k.indexOf(~SPARE~) != -1) newslots.push(i); else { newslots.push(~NORMAL~); } { limitbreakcard.changeslots(newslots); limitbreakcard.animate(~slotschanged~); sfx(~_thinghappens~); } if (selfequipment.length == 0) { self.textparticle(~No equipment!~); } } } }
Lock Advocate+,Lock [lock][yellow]2[] dice,inflict(~lock~[;]2); sfx(~_lock~);
Lucky Roll+,Roll [yellow]two[] [dice]7[yellow]s[],givedice([7[;] 7]);
Mad Dog's Howl+,Inflict [weaken][yellow]4[] weaken,inflict(~weaken~[;]4); sfx(~_weaken~);
Ice Age+,Freeze [ice][yellow]all[] dice,inflict(ICE[;] ALL); sfx(~_ice~);
Melting Ice+,[95%]Inflict [fire][yellow]2[] and [ice][yellow]2[],inflict(~fire[;]2~); inflict(~ice[;]2~); sfx(~_fire~); sfx(~_ice~);
Midnight Snake+,[80%]Roll a [dice]6[;] and a [dice]1[;] [yellow]and a [dice][yellow]7[],givedice([6[;] 1[;] 7]);
Nanomachines+,Gain [reduce][yellow]3[] reduce,inflictself(~reduce~[;] 3); sfx(~_shield~);
Perfect Spanner+,[75%]Combine all dice into one[yellow][;] clone result[],/*storedprizeimmune*/ var dicenumber = 0; for(mydice in self.dicepool){ if(mydice.available()){ dicenumber += mydice.basevalue + mydice.modifier; mydice.removedice(); } } if(dicenumber != 0){ givedice([dicenumber[;] dicenumber]); }
Persona+,Gain [fury][yellow]2[] fury,inflictself(~fury~[;] 2); sfx(~_fury~);
Prickly Pear+,Gain [thorns][yellow]3[] thorns,inflictself(~thorns~[;]3); sfx(~_thorns~);
Prince's Steal+,[80%]Borrow(?) equipment and upgrade it,/*storedprizeimmune*/ var enemyequipment = []; for (eq in target.equipment){ if(!eq.hastag(~cannotsteal~)){ enemyequipment.push(eq); } } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); randomequipment.availablenextturn = false; randomequipment.unavailabletext = ~Borrowed!~; randomequipment.unavailabledetails = [~\~Borrowed\~ until~[;]~next turn.~]; giveequipment(randomequipment.name + randomequipment.namemodifier + ~+~); }
Reshuffle+,[80%]Reroll jackpot options[;] [yellow]upgrade all[],/*storedprizeimmune*/ runscript(~jackpotofalltrades/resetjackpot~[;] [true]); self.roll_jackpotbonus += 1; self.getskillcard().skillsavailable[self.getskillcard().skills.indexOf(~Reshuffle+~)] = true; sfx('jackpot_reducecounter');
Ripper Mode+,[80%]Next turn[;] deal [sword][yellow]3[] extra damage,inflictself(~rippermodefail~[;] 3);
Run It Back+,[80%]Start a new turn [yellow]after this one[],inflictself(EXTRATURN); sfx(~_fury~);
Salvaging+,[85%]Re-use next [yellow]2[] equipment,inflictself(REEQUIPNEXT[;] 2); sfx(~_recycle~);
Sandvich+,Heal [heal][yellow]4[] health,attackself(-4); sfx(~_heal~);
Slingshot+,Do [sword][yellow]7[] damage,attack(7); sfxdamage(7);
Slippery Shoes+,Gain [dodge][yellow]2[] dodge,inflictself(~dodge~[;] 2); sfx(~_dodge~);
Sniper Shot+,[90%]Reduce enemy health by [heart][yellow]7[],pierceattack(7); sfx(~_plasma~);
Split Path+,[70%]Trigger adjacent jackpot skills[yellow][;] reroll[],/*storedprizeimmune*/ var storedSkillIndex = -1; for(j in 0...3){ if(j != 1){ if(self.getskillcard().skills[j].name.indexOf(~Reshuffle~) != -1){ storedSkillIndex = j; continue; } else{ if(self.getskillcard().skillsavailable[j]){ self.getskillcard().skills[j].execute(self[;] target); self.getskillcard().skillsavailable[j] = false; } } } else{ self.getskillcard().skillsavailable[j] = true; } }  if(storedSkillIndex != -1){ self.getskillcard().skills[storedSkillIndex].execute(self[;] target); } self.roll_jackpotbonus += 1; runscript(~jackpotofalltrades/resetjackpot~[;] [false[;] true]);
Stars And Time+,[75%]Revert [heart] to last turn ([heart]<var:previousroundplayerhp>[])[;] [yellow]and heal [health][yellow]3,/*storedprizeimmune*/ if(self.getvar(~previousroundplayerhp~) != 0){ self.hp = self.getvar(~previousroundplayerhp~); self.hp += 3; sfx(~_heal~); } sfx(~_loop~);
Stored Prize+,[90%]Next Jackpot skill goes [yellow]thrice[],/*storedprizeimmune*/ inflictself(~storedprize~[;] 2); sfx(~stealgold~);
Stress+,Inflict [weaken][yellow]2[] weaken,inflict(WEAKEN[;] 2); sfx(~_weaken~);
Suit Up+,Gain [reduce][yellow]2[] reduce,inflictself(~reduce~[;] 2); sfx(~_shield~);
Syringe+,Drain [heart][yellow]4[] health,drain(4); sfx(~_drain~);
Timebomb+,[95%]Do [fire]15 damage in [yellow]2 turns,jinx(~Timebomb~[;]~take [fire]15 damage~[;]~Take [fire]15 damage~[;]~attack(15[;] FIRE); sfx(\~_fire\~);~[;] target[;] self[;] 2[;] d); sfx(~_shock~);
Tri Attack+,[90%]Inflict [fire][yellow]2[][;] [ice][yellow]2[] and [shock][yellow]2[],inflict(FIRE[;]2); inflict(ICE[;]2); inflict(SHOCK[;]2); sfx(~_fire~); sfx(~_ice~); sfx(~_shock~);
Uninnate+,[yellow]Steal[] the Enemy's Innate,/*storedprizeimmune*/ var length = target.innate.length; for(i in 0...length){ self.innate.push(target.innate[0]); if(target.innate[0] == ~vampire~){ removestatus(~vampire~); inflictself(~vampire~); } else{ var extra = ~~; if(i > 0) extra += i; inflictself(~placeholder~ + extra); }  if(target.innate[0].indexOf(~ups [fire] cost~) != -1){ removestatus(~jayinnate~); inflictself(~jayinnate~); } if(target.innate[0].indexOf(~loses [gold]1 gold~) != -1){ removestatus(~losegoldinnate~); inflictself(~jayinnate~); }  target.innate.remove(target.innate[0]); }  sfx(~_thinghappens~); screenshake(); target.innate = [];
Used Syringe+,[70%]Inflict [yellow]2[] random bad status effect[yellow]s[],var NegativeStatusList = [~ice~[;] ~ice_all~[;] ~fire~[;] ~fire_all~[;] ~shock~[;] ~silence~[;] ~blind~[;] ~poison~[;] ~lock~[;] ~curse~[;] ~confuse~]; var additionalStatuses = [~reuseblock~[;] ~bluescorch~[;] ~smorify~[;] ~weaken@p~[;] ~staticshock~]; for(i in 0...NegativeStatusList.length){ additionalStatuses.push(~alternate_~ + NegativeStatusList[i]); }  additionalStatuses.push(~counter_~ + rand([1[;]2[;]3[;]4[;]5[;]6])); additionalStatuses.push(~dice_trigger_~ + rand([1[;]2[;]3[;]4[;]5[;]6])); NegativeStatusList.push(~vanish~); for(i in 0...2){ var pickedStatus = rand(NegativeStatusList.concat(additionalStatuses)); inflict(pickedStatus); if(NegativeStatusList.indexOf(pickedStatus) != -1) sfx(~_~ + s); else sfx(~_weaken~); }
Whoopie Cushion+,Inflict [poison]1 poison,sfx(~_fart~); inflict(~poison~[;]1);
PC Fans,[80%]Your next 3 calculates are [dice]1s,inflictself(~pcfans~[;] 3); sfx(~_ice~);
PC Fans+,[80%]Your next [yellow]5[] calculates are [dice]1s,inflictself(~pcfans~[;] 5); sfx(~_ice~);
Containment Wave+,[80%]Lock [yellow]2[] random Enemy equipment,if(target != null) { var enemyequipment = []; for (eq in target.equipment){ if(!eq.hastag(~cannotsteal~) && eq.availablenextturn){ enemyequipment.push(eq); } } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); randomequipment.availablenextturn = false; randomequipment.unavailabletext = ~Locked!~; randomequipment.unavailabledetails = [~Locked until~[;]~next turn.~]; enemyequipment.remove(randomequipment); } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); randomequipment.availablenextturn = false; randomequipment.unavailabletext = ~Locked!~; randomequipment.unavailabledetails = [~Locked until~[;]~next turn.~]; enemyequipment.remove(randomequipment); } } sfx(~_lock~);
Headshot,[90%]Reduce enemy health by [heart]7,pierceattack(7); sfx(~_plasma~);
Headshot+,[90%]Reduce enemy health by [heart][yellow]9[],pierceattack(9); sfx(~_plasma~);
The Blue Devil,[80%]Burn [fire]2 dice[;] they cost [heart]+2 health,inflict(~fire~[;] 2); sfx(~_fire~); inflict(~bluescorch~[;] 2);
The Blue Devil+,[80%]Burn [fire][yellow]3[] dice[;] they cost [heart]+3 health,inflict(~fire~[;] 3); sfx(~_fire~); inflict(~bluescorch~[;] 3);
bigbertha,This equipment's effects are|passive[;] gained on pickup,
Play Hooky,Turn all [recycle]re-uses into [retrigger]re-triggers this turn (and vice versa),if(self.hasstatus(~retriggerall~)){ removestatusself(~retriggerall~); } else { inflictself(~retriggerall~[;] 1); } for(eq in self.equipment){ if(eq.hastag(~unlockonlimit~)){ eq.availablethisturn = true; eq.animate(~flashandshake~); if(eq.name == ~Scabbarded Stabber~){ eq.setvar(~redice~[;] [1[;]2[;]3[;]4[;]5[;]6]); eq.changecolour(~RED~); } } } sfx(~_fury~); sfx(~_hooky~); runscript(~pirate/reusetoretriggerdescreplace~[;] []); self.setvar(~limitcharge~[;] 0);
Smeared Roll,Reroll all your dice into values that can trigger a [recycle]|(Random value if no on [recycle] exists),var reusevals = runscript(~pirate/hookedroll~[;] [self[;] e]); var c = 0; if(self != null) { if(self.dicepool != null) { if (self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ mydice.animatereroll((rand(reusevals))[;] self.screenposition()[;] c * 0.05); } c++; } } } } sfx(~_thinghappens~); sfx(~_recycle~); for(eq in self.equipment){ if(eq.hastag(~unlockonlimit~)){ eq.availablethisturn = true; eq.animate(~flashandshake~); if(eq.name == ~Scabbarded Stabber~){ eq.setvar(~redice~[;] [1[;]2[;]3[;]4[;]5[;]6]); } } } self.setvar(~limitcharge~[;] 0);
Maroon The Chad,Turn all [recycle]re-uses into [retrigger]re-triggers this turn[;] |equipment can [retrigger] on any value,if(self.hasstatus(~maroonall~)){ removestatusself(~maroonall~); } else { inflictself(~maroonall~[;] 1); } for(eq in self.equipment){ if(eq.hastag(~unlockonlimit~)){ eq.availablethisturn = true; eq.animate(~flashandshake~); eq.setvar(~redice~[;] [1[;]2[;]3[;]4[;]5[;]6]); if(eq.name == ~Scabbarded Stabber~){ eq.changecolour(~RED~); } } } sfx(~_fury~); sfx(~_hooky~); runscript(~pirate/reusetoretriggerdescreplace~[;] []); self.setvar(~limitcharge~[;] 0);
What,What,self.textparticle(~What~); sfx(~_thinghappens~);
Electrocute,Inflict [staticshock]2 static shock,var multiplier = 1.0; if(target.innate.indexOf(~weakshock~) != -1) multiplier *= 2; if(target.innate.indexOf(~strongshock~) != -1) multiplier /= 2; sfx(~_shock~); inflict(~staticshock~[;] 2 * multiplier);
Electrocute+,Inflict [staticshock][yellow]3[] static shock,var multiplier = 1.0; if(target.innate.indexOf(~weakshock~) != -1) multiplier *= 2; if(target.innate.indexOf(~strongshock~) != -1) multiplier /= 2; sfx(~_shock~); inflict(~staticshock~[;] 3 * multiplier);
Full Restore,[65%]Gain every single positive status effect,inflictself(~randompronouns~); var statusList = [~dodge~[;] ~fury~[;] ~reequipnext~[;] ~reduce~[;] ~recycle~[;] ~pierce~[;] ~shield~[;] ~survive~[;] ~thorns~[;] ~luck~[;] ~mana~]; var additionalstatus = [~cpuprotect~[;] ~cpushield~[;] ~luck+~[;] ~alternate_shield~[;] ~alternate_dodge~[;] ~alternate_reduce~[;] ~alternate_reequipnext~[;] ~alternate_thorns~[;] ~againstallodds~[;] ~extradamage~[;] ~reflectexcess~[;] ~jackpotrangeup~[;] ~manualroll~[;] ~jackpotshard~[;] ~storedprize~[;] ~vortex~[;] ~pcfans~]; for(s in statusList){ inflictself(s); sfx(~_~ + s); } for(s in additionalstatus){ inflictself(s); }
Full Restore+,[65%]Gain every single positive status effect [yellow]x2[],inflictself(~randompronouns~); var statusList = [~dodge~[;] ~fury~[;] ~reequipnext~[;] ~reduce~[;] ~recycle~[;] ~pierce~[;] ~shield~[;] ~survive~[;] ~thorns~[;] ~luck~[;] ~mana~]; var additionalstatus = [~cpuprotect~[;] ~cpushield~[;] ~luck+~[;] ~alternate_shield~[;] ~alternate_dodge~[;] ~alternate_reduce~[;] ~alternate_reequipnext~[;] ~alternate_thorns~[;] ~againstallodds~[;] ~extradamage~[;] ~reflectexcess~[;] ~jackpotrangeup~[;] ~manualroll~[;] ~jackpotshard~[;] ~storedprize~[;] ~vortex~[;] ~pcfans~]; for(s in statusList){ inflictself(s[;] 2); sfx(~_~ + s); } for(s in additionalstatus){ inflictself(s[;] 2); }
