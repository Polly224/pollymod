Name,Displayed As,Symbol,Description,Stacks?,Remove at End Turn?,Remove at Start Turn?,Invisible?,Blocked by Reduce?,Script: When inflicted,Script: On any status infliction,Script: Before Start Turn,Script: On Start Turn,Script: On any equipment use,Script: On any countdown reduce,Script: End Turn,Script: After Combat,Script: On damage inflicted,Script: On damage taken,Script: On status remove
Dice Big,,,what|https://i.imgur.com/P3zIMxe.png,NO,NO,NO,YES,NO,var s = new elements.Skill(~Dice Fubny~); var tw = new motion.actuators.SimpleActuator(null[;]1[;]null); tw._repeat = -1; tw.onRepeat(s.execute[;][self[;]target]); tw.move(); s.remove(); /* i don't think the mod uses this anymore i don't remember teehee */ /* not gonna remove it and find out though */,,,,,,,,,,
jackpotrangeup,Increased_Range,jackpot,Increase jackpot range by <value> at the start of your turn.,YES,NO,NO,NO,NO,,,,self.roll_range += getstatusself(~jackpotrangeup~); self.getskillcard().animate(~flashandshake~); sfx(~_thinghappens~); removestatusself(~jackpotrangeup~[;] ALL);,,,,,,,
rippermode,Ripper_Mode,rippermode,Do [sword]<value> extra damage with each attack this turn.,YES,YES,NO,NO,NO,,,,,,,,,target.hp -= getstatusself(~rippermode~);,,
rippermodefail,Ripper_Mode,rippermode,Do [sword]<value> extra damage with each attack next turn.,YES,NO,NO,NO,NO,,,inflictself(~rippermode~[;] getstatusself(~rippermodefail~)); removestatusself(~rippermodefail~[;] ALL);,,,,,,,,
manualroll,Guaranteed_Jackpot,star,Autoroll automatically <value> time(s).,YES,NO,NO,NO,NO,var s = new elements.Skill(~Against All Odds_old~); var act = new motion.actuators.SimpleActuator(null[;] 0.001[;] null); act.onComplete(s.execute[;] [self[;] target]); s.script = ~ if(!self.roll_error && !self.roll_jackpot){ removestatusself(\~manualroll\~[;] 1); robotroll(true); self.getskillcard().animate(\~flashandshake\~); } else{ sfx(\~jackpot_autoroll\~); } ~; act.move();,,var s = new elements.Skill(~Against All Odds_old~); var act = new motion.actuators.SimpleActuator(null[;] 0.1[;] null); act.onComplete(s.execute[;] [self[;] target]); s.script = ~robotroll(true); self.getskillcard().animate(\~flashandshake\~); removestatusself(\~manualroll\~[;] 1); ~; act.move();,,,,,,,,
survivenomorehehe,,dice3,Big Boner Down The Lane (this erro rmesage)[;][;]    if you're readin' this... talk ta polly...,NO,NO,NO,YES,NO,,,,removestatusself(~survive~[;] ALL); removestatusself(~survivenomorehehe~[;] ALL);,,,,,,,
cursenext,Incoming_Curse,curse,You've cursed yourself for the next turn...,YES,NO,NO,NO,NO,,,,inflictself(~curse~[;] getstatusself(~cursenext~)); sfx(~_curse~); removestatusself(~cursenext~[;] ALL);,,,,,,,
storedprize,Stored_Prize,jackpot,[95%]Next Jackpot skill gets used <value> extra time(s).,YES,NO,NO,NO,NO,var act = new motion.actuators.SimpleActuator(null[;] 0.1[;] null); var s = new elements.DiceyScript(~if(self.roll_jackpot > 0 && self.getskillcard().skills.length >= 3){   for(i in 0...self.getskillcard().skills.length){     var s = self.getskillcard().skills[i];     if(s.script.indexOf(\~storedprizeinjected\~) == -1 && s.script.indexOf(\~storedprizeimmune\~) == -1){       s.script += \~ /*storedprizeinjected*/ if(self.hasstatus(\\\~storedprize\\\~)){var st = self.getstatus(\\\~storedprize\\\~);var newskill = new elements.Skill(\\\~\~+s.name+\~\\\~);var act = new motion.actuators.SimpleActuator(null[;] 0.15+st.value*0.15[;] null);act.onRepeat(newskill.execute[;][self[;]target]);act._repeat = st.value;act.move();self.removestatus(\\\~storedprize\\\~);}\~;     }   } }~); act.onRepeat(s.execute[;] [self[;] target]); act._repeat = -1; s.set(~act~[;] act); s.set(~self~[;] self); act.move();,,,,,,,,,,
storedbonus,Stored_Bonus,jackpot,Bonus Payout will trigger <value> time(s) next turn.,YES,NO,NO,NO,NO,,,,self.roll_jackpotbonus += getstatusself(~storedbonus~); self.roll_range += getstatusself(~storedbonus~); adjustrobotcounter(0); removestatusself(~storedbonus~[;] ALL);,,,,,,,
storedbonusupgraded,Stored_Bonus+,jackpot,Bonus Payout+ will trigger <value> time(s) next turn.,YES,NO,NO,NO,NO,,,,self.roll_jackpotbonus += getstatusself(~storedbonus~); self.roll_range += getstatusself(~storedbonus~) * 2; adjustrobotcounter(0); removestatusself(~storedbonus~[;] ALL);,,,,,,,
survivenextturn,Survive_Next_Turn,curse,Gain 1 survive next turn.,NO,NO,NO,NO,NO,,,,inflictself(~survive~[;]1); inflictself(~survivenomorehehe~[;]1); removestatusself(~survivenextturn~);,,,,,,,
placeholder,Stolen_Innate_1,star,(This should always be replaced! If you're reading this[;] it's a bug!)|(Used with Uninnate+!),NO,NO,NO,NO,NO,runscript(~jackpotofalltrades/uninnate+~[;] [status[;] target]);,,,,,,,,,,
jackpotshard,Jackpot_Shard,jackpotshard,4 Jackpot Shards combine into an automatic Autoroll.,YES,NO,NO,NO,NO,,,,,,,,,,,
iceallnextturn,Frozen_all,ice,Freeze all your dice next turn.,NO,NO,NO,NO,NO,,,inflictself(~ice_all~); removestatusself(~iceallnextturn~);,,,,,,,,
icenextturn,Frozen,ice,Gain <value> freeze next turn.,YES,NO,NO,NO,NO,,,inflictself(~ice~[;] getstatusself(~icenextturn~)); removestatusself(~icenextturn~[;] ALL);,,,,,,,,
extrajackpotskill,Bonus_Slot,gold,Your jackpot has <value> extra options. Shouldn't show up! If it does[;] it's buggin... and that ain't thuggin...,YES,NO,NO,YES,NO,/* i might be descending into insanity */,,,,,,,,,,
virus,Virus,virus,Take <value> damage at the end of your turn if you triggered an error during it.,YES,NO,NO,NO,NO,,,,,,,if(self.roll_error){ attackself(getstatusself(~virus~)); sfxdamage(getstatusself(~virus~)); } /*A leftover thingy from when I wanted to add custom enemies to the game. This one ain't that great. Turns Slime into an unloseable fight.*/,,,,
bsodtriggered,ShouldntAppear!,virus,You know the gist. It's invisible[;] BITCH!!!! What're you poking around for[;] damn!!!!,NO,NO,YES,YES,NO,/*ok im sorry for swearing in the description that was very mean of me i won't do it again i prommy [heart]*/,,,,,,,,,,
bigberthavisual,Big_Bertha,star,Every jackpot skill has a 33% chance to be upgraded when rolled.,NO,NO,NO,NO,NO,,,,,,,,,,,
bsodvisual,BSOD,star,When you trigger an error[;] you can still use your jackpot skills.,NO,NO,NO,NO,NO,,,,,,,,,,,
bluedevilcredits,Credits,devilfire,The Blue Devil is a skill made by Jultima!,NO,NO,YES,NO,NO,,,,,,,,,,,
retriggerall,Retrigger_All,retrigger,Whenever you re-use an equipment[;] re-trigger it instead with the same dice.,NO,YES,NO,NO,NO,,,,,,,,,,,runscript(~pirate/reusetoretriggerdescreplace~[;] []);
retriggernext,Retrigger_Next,retrigger,Whenever you re-use an equipment[;] re-trigger it instead with the same dice. Unimplemented.,YES,YES,NO,NO,NO,,,,,,,,,,,
doublespookyfury,Spooky_Fury,fury,50% chance to use the next equipment twice[;]|lasts until something triggers it.,YES,YES,NO,YES,NO,,,,,,,,,,,
reequippolly,,recycle,Inflict this with [recycle] on x equips[;] like Pirate Hook.,NO,NO,NO,YES,NO,if((self.hasstatus(~curse~) && chance(Rules.curseodds))){ for(eq in self.equipment){ if(eq.slots.length > 0){ eq.addtag(~curseattract~); eq.removetag(~curseavoid~); } } } else{ if(!self.hasstatus(~reuseblock~)){ if(self.hasstatus(~retriggerall~) # self.hasstatus(~maroonall~)){ sfx(~_recycle~[;] 1); sfx(~_fury~[;] 1); inflictself(~doublespookyfury~); } else{ inflictself(~reequipnext~); sfx(~_recycle~[;]~~[;]0.2); } removestatusself(~reequippolly~[;] ALL); for(eq in self.equipment){ if(eq.slots.length > 0){ eq.addtag(~curseavoid~); eq.removetag(~curseattract~); } if(eq.hastag(~triggersonreuse~)){ eq.doequipmentaction(self[;] target[;] 1[;] [][;] 0.1[;] true[;] false[;] false); } }   self.setvar(~turnreusecount~[;] self.getvar(~turnreusecount~) + 1); self.setvar(~doublereusecount~[;] self.getvar(~turnreusecount~) * 2); } },,,,,,,,,,
reequippolly@nouse,,,Inflict this when gaining re-uses from an equipment that |doesn't immediately use them. e.g. Hookshot. Unimplemented.,NO,NO,NO,YES,NO,if(self.hasstatus(~retriggerall~)){ inflictself(~retriggernext~); sfx(~_fury~); } else{ inflictself(~reequipnext~); sfx(~_recycle~[;]~~[;]0.2); } removestatusself(~reequippolly@nouse~[;] ALL);,,,,,,,,,,
retriggerpolly,,retrigger,Inflict this with [retrigger] on x equips[;] like the second half of Which Way[;] Captain?.,NO,NO,NO,YES,NO,if((self.hasstatus(~curse~) && chance(Rules.curseodds))){ for(eq in self.equipment){ if(eq.slots.length > 0){ eq.addtag(~curseattract~); eq.removetag(~curseavoid~); } } } else{ if(!self.hasstatus(~reuseblock~)){ if(self.hasstatus(~retriggerall~) # self.hasstatus(~maroonall~)){ inflictself(~reequipnext~); sfx(~_recycle~[;]~~[;]0.2); } else{ sfx(~_recycle~[;] 1); sfx(~_fury~[;] 1); inflictself(~doublespookyfury~); } removestatusself(~reequippolly~[;] ALL); for(eq in self.equipment){ if(eq.slots.length > 0){ eq.addtag(~curseavoid~); eq.removetag(~curseattract~); } if(eq.hastag(~triggersonreuse~)){ eq.doequipmentaction(self[;] target[;] 1[;] [][;] 0.1[;] true[;] false[;] false); } }  removestatusself(~landlubbershack~[;] 1); self.setvar(~turnreusecount~[;] self.getvar(~turnreusecount~) + 1); self.setvar(~doublereusecount~[;] self.getvar(~turnreusecount~) * 2); } },,,,,,,,,,
maroonall,Marooned_Chad,retrigger,Whenever you use an equipment[;] re-trigger it instead with the same dice.,NO,YES,NO,NO,NO,,,,,,,,,,,runscript(~pirate/reusetoretriggerdescreplace~[;] []);
recycleon1,1_Re-Use,reuseon1,Your next <value> equipment can [recycle] on 1.,YES,YES,NO,NO,NO,,,,,,,,,,,
recycleon2,2_Re-Use,reuseon2,Your next <value> equipment can [recycle] on 2.,YES,YES,NO,NO,NO,,,,,,,,,,,
recycleon3,3_Re-Use,reuseon3,Your next <value> equipment can [recycle] on 3.,YES,YES,NO,NO,NO,,,,,,,,,,,
recycleon4,4_Re-Use,reuseon4,Your next <value> equipment can [recycle] on 4.,YES,YES,NO,NO,NO,,,,,,,,,,,
recycleon5,5_Re-Use,reuseon5,Your next <value> equipment can [recycle] on 5.,YES,YES,NO,NO,NO,,,,,,,,,,,
recycleon6,6_Re-Use,reuseon6,Your next <value> equipment can [recycle] on 6.,YES,YES,NO,NO,NO,,,,,,,,,,,
reuseblock,Re-Unusable,reuseblock,The next <value> equipment you [recycle]re-use or [retrigger]re-trigger gets used normally instead.|(This gets removed at the end of your turn.),YES,YES,NO,NO,NO,,if(inflicted_type == ~reequippolly~ # inflicted_type == ~retriggerpolly~) removestatusself(~reuseblock~[;] 1);,,,,,,,,,
bluescorch,Faerie_Fire,devilfire,Burning dice cost [heart]<value> health more to extinguish this turn.,YES,YES,NO,NO,NO,self.symbolparticle(~devilfire~);,,Rules.burningdicecost += getstatusself(~bluescorch~); var act = new motion.actuators.SimpleActuator(null[;] 0.01[;] null); var s = new elements.DiceyScript(~for (dice in self.dicepool) {if(dice.overlayimage == 'fire' && self.getstatus('bluescorch') > 0){self.setvar(\~blueact\~[;] act);         dice.overlayimage = 'hellfire'; var frame1 = new displayobjects.HaxegonSprite(0[;] 0[;] 'ui/dice/hellburn/flame20000'[;] 0[;] 0); dice.graphic.overlayimage = frame1; for(i in 0...17){var val = 20000 + i + 1; dice.graphic.overlayimage.addimageframe('ui/dice/hellburn/flame' + val);}}}~); s.set(~self~[;] self); s.set(~act~[;] act); act.onRepeat(s.execute[;] [self[;] target]); act._repeat = -1; act.move();,,,,,,,,Rules.burningdicecost -= getstatusself(~bluescorch~); trace(self.getvar(~blueact~)); self.getvar(~blueact~)._repeat = 0;
reuseroll,Re-Use_Roll,recycle,The next <value> dice you roll that can't trigger |a [recycle]re-use reroll into ones that can. (Unimplemented),NO,NO,NO,NO,NO,var s = new elements.Skill(~Against all odds_old~); var act = new motion.actuators.SimpleActuator(); /*rurd stands for ~re-use rerolled dice~*/ if(self.getvar(~rurd~) == 0){ self.setvar(~rurd~[;] []); } s.script = ~ var reusevals = []; for(eq in self.equipment){ if(eq.ready){ if(eq.getvar(\~redice\~).length > 0){ if(eq.remainingcountdown > 0 && eq.remainingcountdown < 7){ reusevals.push(eq.remainingcountdown); } else{ if(eq.getvar(\~redice\~)[0] < 7){ reusevals = reusevals.concat(eq.getvar(\~redice\~)); } } } if(eq.getvar(\~retdice\~).length > 0){ reusevals = reusevals.concat(eq.getvar(\~retdice\~)); } } } var canreroll = false; if(reusevals.length > 0){ canreroll = true; }  if(canreroll){ for(mydice in self.dicepool){ if(reusevals.indexOf(mydice.basevalue + mydice.modifier) == -1 && !mydice.intween() && self.getvar(\~rurd\~).indexOf(mydice) == -1){ mydice.animate(\~flashshake\~); mydice.animation[mydice.animation.length - 1].addcommand(\~textparticle\~[;] \~[recycle] Re-useable! [recycle]\~[;]\~0xffffff\~); mydice.basevalue = rand(reusevals); mydice.modifier = 0; var temparr = self.getvar(\~rurd\~); temparr.push(mydice); self.setvar(\~rurd\~[;] temparr); removestatusself(\~reuseroll\~[;] 1); } } } ~; act.onRepeat(s.execute[;] [self[;] target]); act._repeat = -1; act.move(); self.setvar(~reuserollact~[;] act);,,,,,,,self.getvar(~reuserollact~).repeat = 0;,,,self.getvar(~reuserollact~).repeat = 0;
golddisplay,Gold,gold,Has [gold]<var:goldamount> gold.,YES,NO,NO,NO,NO,status._displayvalue = self.gold; self.setvar(~goldamount~[;] self.gold);,,,,status._displayvalue = self.gold; self.setvar(~goldamount~[;] self.gold);,,,,,,
vortex,Vortex,vortex,Whenever you create [vortex]10 vortexes[;] |you drain [heart]10 health from your enemy.,YES,NO,NO,NO,NO,while(getstatusself(~vortex~) >= 10) { removestatusself(~vortex~[;] 10); drain(10); sfx(~_drain~); },,,,,,,,,,
cpunerf,CPU_Down,dice,CPU is reduced by <value> for this turn.,YES,NO,NO,NO,NO,,,self.roll_target -= getstatusself(~cpunerf~);,,,,self.roll_target += getstatusself(~cpunerf~); removestatusself(~cpunerf~[;] ALL);,,,,
smorify,Smorify,smore,You're a smore[;] now.,NO,NO,NO,NO,NO,target.vfxoffset.y -= target.graphic.get_height() / 5; sfx(~_thinghappens~); target.symbolparticle(~beartransform~); var delayedcheck = new motion.actuators.SimpleActuator(null[;] 0.3[;] null); var s = new elements.Skill(~Against all odds_old~); s.script = ~target.graphicyoff += target.graphic.get_height() / 2;target.graphic.set_height(target.graphic.get_height() / 5);~; delayedcheck.onComplete(s.execute[;] [self[;]target]); delayedcheck.move(); /* Lmao. */,,,,,,,,,,target.vfxoffset.y += target.graphic.get_height(); sfx(~_thinghappens~); target.symbolparticle(~beartransform~); var delayedcheck = new motion.actuators.SimpleActuator(null[;] 0.3[;] null); var s = new elements.Skill(~Against all odds_old~); s.script = ~target.graphic.set_height(target.graphic.get_height() * 5);target.graphicyoff -= target.graphic.get_height() / 2;~; delayedcheck.onComplete(s.execute[;] [self[;]target]); delayedcheck.move();
limittracker,Pirate_Is_The_Roaring_Knight???,star,keeps track of the player's limit charge for glowing cutlass.,NO,NO,NO,YES,NO,self.setvar(~limitcharge~[;] self.limitvalue);,self.setvar(~limitcharge~[;] self.limitvalue);,,,,,,,,self.setvar(~limitcharge~[;] self.limitvalue + 1);,
jayinnate,,,(Shouldn't show up[;] increases burn costs every turn and updates innate to show burn cost dynamically.),NO,NO,NO,YES,NO,if(!self.isplayer) self.innate = [~strongfire~[;] ~ups [fire] cost by 1/turn ([fire]~ + Rules.burningdicecost + ~[])~];,,,,if(!self.isplayer) self.innate = [~strongfire~[;] ~ups [fire] cost by 1/turn ([fire]~ + Rules.burningdicecost + ~[])~];,,Rules.burningdicecost += 1; if(!self.isplayer) self.innate = [~strongfire~[;] ~ups [fire] cost by 1/turn ([fire]~ + Rules.burningdicecost + ~[])~]; target.symbolparticle(~fire~); target.textparticle(~Burn cost up!~); sfx(~_fire~);,,,,
countdownrediceupdate,Shla_Boing_Boing,cog,(Shouldn't appear. Makes sure specific countdown equipment can get properly re-used.),NO,NO,NO,YES,NO,,,,,,if(e.name == ~Reinforced Leg~){ if(e.dicehistory.length > 0){ var resultval = e.remainingcountdown - e.reducecountdownby - (e.dicehistory[e.dicehistory.length - 1].basevalue + e.dicehistory[e.dicehistory.length - 1].modifier); if(resultval > 0){ var redicelist = []; for(i in 1...7){ if(i > resultval){ redicelist.push(i); } } e.setvar(~redice~[;] redicelist); e.setvar(~ogredice~[;] redicelist); } } } else if(e.name == ~Charge 'N Load~){ if(e.dicehistory.length > 0){ var resultval = e.remainingcountdown - e.reducecountdownby - (e.dicehistory[e.dicehistory.length - 1].basevalue + e.dicehistory[e.dicehistory.length - 1].modifier); if(resultval > 0){ e.setvar(~redice~[;] [resultval]); e.setvar(~ogredice~[;] [resultval]); } } } /* Normal On any countdown reduce scripts trigger for any equipment[;] only the status version of it actually tells you which equipment had its countdown reduced[;] so this way of doing it is sadly necessary. */,,,,,
luckysevensslot,,jackpot,Keeps track of the Lucky Sevens' Slot equipment. (Shouldn't show up.),NO,YES,NO,YES,NO,var s = new elements.DiceyScript(~ var options = []; for(eq in self.equipment) {  if(eq.name == 'Slot' && eq.finalpos != null) { options.push(eq); } } if(options.length > 0) {  for(eq in options) { if(!eq.hastag('slotpicked')){ if(eq.x == eq.finalpos.x && eq.y == eq.finalpos.y && getactivefighter() == self){ eq.addtag('slotpicked'); sfx('jackpot_reducecounter'); screenshake(); } } if(!eq.availablethisturn) eq.changeslots(['MAX2']); if((eq.x != eq.finalpos.x # eq.y != eq.finalpos.y) && eq.ready && eq.availablethisturn && getactivefighter() == self) { var vals = ['REQUIRE1'[;] 'REQUIRE2'[;] 'REQUIRE3'[;] 'REQUIRE4'[;] 'REQUIRE5'[;] 'REQUIRE6']; vals.remove(eq.slots[0]);  var picked = rand(vals); eq.changeslots([picked]); } } } ~); var act = new motion.actuators.SimpleActuator(null[;] 0.07[;] null); act.onRepeat(s.execute[;] [self[;] target]); act._repeat = -1; s.set('self'[;] self); s.set('target'[;] target); s.set('rand'[;] rand); s.set('sfx'[;] sfx); s.set('screenshake'[;] screenshake); s.set('getactivefighter'[;] getactivefighter); act.move(); self.setvar('luckysevenact'[;] act);,,,,,,,,,,self.getvar(~luckysevenact~)._repeat = 0;
losegoldinnate,,,(Shouldn't show up[;] makes Treasure Chest lose [gold]1 gold every turn.),NO,NO,NO,YES,NO,,,if(self.gold > 0) self.gold -= 1;,,,,,,,,
placeholder1,Stolen_Innate_2,,(This should always be replaced! If you're reading this[;] it's a bug!)|(Used with Uninnate+!),NO,NO,NO,NO,NO,runscript(~jackpotofalltrades/uninnate+~[;] [status[;] target]);,,,,,,,,,,
placeholder2,Stolen_Innate_3,,(This should always be replaced! If you're reading this[;] it's a bug!)|(Used with Uninnate+!),NO,NO,NO,NO,NO,runscript(~jackpotofalltrades/uninnate+~[;] [status[;] target]);,,,,,,,,,,
placeholder3,Stolen_Innate_4,,(This should always be replaced! If you're reading this[;] it's a bug!)|(Used with Uninnate+!),NO,NO,NO,NO,NO,runscript(~jackpotofalltrades/uninnate+~[;] [status[;] target]);,,,,,,,,,,
weaken@p,Weaken,weaken,Temporarily weakens random equipment.|Equipment becomes less powerful.,YES,YES,NO,NO,NO,,,,,,,,,,,
weakenfixer,,,(Replaces the weaken status effect with weaken@p.),NO,NO,NO,YES,NO,,if(inflicted_type == ~weaken~){ var delayedcheck = new motion.actuators.SimpleActuator(null[;] 0.01[;] null); var s = new elements.Skill(~Against all odds_old~); s.script = ~inflictself('weaken@p'[;] getstatusself('weaken')); removestatusself('weaken'[;] getstatusself('weaken'));~; delayedcheck.onComplete(s.execute[;] [self[;]target]); delayedcheck.move(); },,,,,,,,,
staticshock,Static_Shock,staticshock,Keeps <value> equipment shocked until a dice is used to unshock it.,YES,NO,NO,NO,NO,status.scriptonshockrelease = ~if(self.varexists(\~staticshockedeq\~)){ for(eq in self.equipment){ var shockedeq = self.getvar(\~staticshockedeq\~); if(eq.shockedsetting == 0 && shockedeq.indexOf(eq) != -1){ shockedeq.remove(eq); removestatusself(\~staticshock\~[;] 1); } } }~;,,if(self.varexists(~staticshockedeq~)){ var shockedeq = self.getvar(~staticshockedeq~); for(eq in shockedeq){ eq.animate(~flash~); eq.animation[eq.animation.length - 1].addcommand(~textparticle~[;] ~[staticshock]Static Shock!~[;] 0xBABABA); eq.shockedtext = ~Place a dice to[newline]discharge static shock.~; eq.shockedsetting = 1; eq.positionshockslots(); delay(0.8); } },var shocklist = []; var shockedeq = []; if(self.varexists(~staticshockedeq~)) shockedeq = self.getvar(~staticshockedeq~); for(eq in self.equipment){ if(!eq.hastag(~shockavoid~) && self.getskillcard() != eq && eq.shockedsetting == 0 && shockedeq.indexOf(eq) == -1){ shocklist.push(eq); } } shuffle(shocklist); if(getstatusself(~staticshock~) - shockedeq.length > 0) sfx(~_shock~); for(i in 0...getstatusself(~staticshock~) - shockedeq.length){ if(shocklist.length > 0){ var eq = shocklist.pop(); eq.animate(~flash~); eq.animation[eq.animation.length - 1].addcommand(~textparticle~[;] ~[staticshock]Static Shock!~[;] 0xBABABA); eq.shockedtext = ~Place a dice to[newline]discharge static shock.~; eq.shockedsetting = 1; eq.positionshockslots(); delay(0.8); shockedeq.push(eq); } } self.setvar(~staticshockedeq~[;] shockedeq);,for(eq in self.equipment){ trace(eq.shockedtext); },,,,,,
randompronouns,(X/X),silence,,NO,NO,NO,NO,NO,/* Randomized pronouns[;] lmao. */ var pronounlist1 = [~he~[;] ~she~[;] ~they~[;] ~it~]; var pronounlist2 = [~him~[;] ~her~[;] ~them~[;] ~its~]; var pronouns = ~~; var pronoun1 = rand(pronounlist1); pronouns += pronoun1 + ~/~; var pronoun2 = rand([0[;]1[;]2[;]3]); if(pronounlist1.indexOf(pronoun1) == pronoun2){ pronouns += pronounlist2[pronoun2]; } else{ pronouns += pronounlist1[pronoun2]; } status.template.displayname = ~(~ + pronouns + ~)~; status.name = ~(~ + pronouns + ~)~; status.template.description = self.name + ~ is going by ~ + pronouns + ~ today.~;,,,,,,,,,,
reusecount,,recycle,(Used for ai to work with equipment like Anchor.),YES,YES,NO,YES,NO,,,,,,,,,,,
retriggercount,,retrigger,(Used for ai that needs to use equipment based off retrigger amount.),YES,YES,NO,YES,NO,,,,,,,,,,,
ctdreducecount,,jackpot,(Used for ai that needs to use equipment based off countdown reductions[;] like Muzzleloading.),YES,YES,NO,YES,NO,,,,,,,,,,,
