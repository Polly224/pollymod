Name,Displayed As,Symbol,Description,Stacks?,Remove at End Turn?,Remove at Start Turn?,Invisible?,Blocked by Reduce?,Script: When inflicted,Script: On any status infliction,Script: Before Start Turn,Script: On Start Turn,Script: On any equipment use,Script: On any countdown reduce,Script: End Turn,Script: After Combat,Script: On damage inflicted,Script: On damage taken,Script: On status remove
Dice Big,,,what|https://i.imgur.com/P3zIMxe.png,NO,NO,NO,YES,NO,var s = new elements.Skill(~Dice Fubny~); var tw = new motion.actuators.SimpleActuator(null[;]1[;]null); tw._repeat = -1; tw.onRepeat(s.execute[;][self[;]target]); tw.move(); s.remove(); /* i don't think the mod uses this anymore i don't remember teehee */ /* not gonna remove it and find out though */,,,,,,,,,,
jackpotrangeup,Increased_Range,jackpot,Increase jackpot range by <value> at the start of your turn.,YES,NO,NO,NO,NO,,,,self.roll_range += getstatusself(~jackpotrangeup~); self.getskillcard().animate(~flashandshake~); sfx(~_thinghappens~); removestatusself(~jackpotrangeup~[;] ALL);,,,,,,,
rippermode,Ripper_Mode,rippermode,Do [sword]<value> extra damage with each attack this turn.,YES,YES,NO,NO,NO,,,,,,,,,target.hp -= getstatusself(~rippermode~);,,
rippermodefail,Ripper_Mode,rippermode,Do [sword]<value> extra damage with each attack next turn.,YES,NO,NO,NO,NO,,,inflictself(~rippermode~[;] getstatusself(~rippermodefail~)); removestatusself(~rippermodefail~[;] ALL);,,,,,,,,
manualroll,Guaranteed_Jackpot,star,Autoroll automatically <value> time(s).,YES,NO,NO,NO,NO,var s = new elements.Skill(~Against All Odds_old~); var act = new motion.actuators.SimpleActuator(null[;] 0.001[;] null); act.onComplete(s.execute[;] [self[;] target]); s.script = ~ if(!self.roll_error && !self.roll_jackpot){ removestatusself(\~manualroll\~[;] 1); robotroll(true); self.getskillcard().animate(\~flashandshake\~); } else{ sfx(\~jackpot_autoroll\~); } ~; act.move();,,var s = new elements.Skill(~Against All Odds_old~); var act = new motion.actuators.SimpleActuator(null[;] 0.1[;] null); act.onComplete(s.execute[;] [self[;] target]); s.script = ~robotroll(true); self.getskillcard().animate(\~flashandshake\~); removestatusself(\~manualroll\~[;] 1); ~; act.move();,,,,,,,,
survivenomorehehe,,dice3,Big Boner Down The Lane (this erro rmesage)[;][;]    if you're readin' this... talk ta polly...,NO,NO,NO,YES,NO,,,,removestatusself(~survive~[;] ALL); removestatusself(~survivenomorehehe~[;] ALL);,,,,,,,
cursenext,Incoming_Curse,curse,You've cursed yourself for the next turn...,YES,NO,NO,NO,NO,,,,inflictself(~curse~[;] getstatusself(~cursenext~)); sfx(~_curse~); removestatusself(~cursenext~[;] ALL);,,,,,,,
storedprize,Stored_Prize,jackpot,[95%]Next Jackpot skill gets used <value> extra time(s).,YES,NO,NO,NO,NO,var act = new motion.actuators.SimpleActuator(null[;] 0.1[;] null); var s = new elements.DiceyScript(~if(self.roll_jackpot > 0 && self.getskillcard().skills.length >= 3){   for(i in 0...self.getskillcard().skills.length){     var s = self.getskillcard().skills[i];     if(s.script.indexOf(\~storedprizeinjected\~) == -1 && s.script.indexOf(\~storedprizeimmune\~) == -1){       s.script += \~ /*storedprizeinjected*/ if(self.hasstatus(\\\~storedprize\\\~)){var st = self.getstatus(\\\~storedprize\\\~);var newskill = new elements.Skill(\\\~\~+s.name+\~\\\~);var act = new motion.actuators.SimpleActuator(null[;] 0.15+st.value*0.15[;] null);act.onRepeat(newskill.execute[;][self[;]target]);act._repeat = st.value;act.move();self.removestatus(\\\~storedprize\\\~);}\~;     }   } }~); act.onRepeat(s.execute[;] [self[;] target]); act._repeat = -1; s.set(~act~[;] act); s.set(~self~[;] self); act.move();,,,,,,,,,,
storedbonus,Stored_Bonus,jackpot,Bonus Payout will trigger <value> time(s) next turn.,YES,NO,NO,NO,NO,,,,self.roll_jackpotbonus += getstatusself(~storedbonus~); self.roll_range += getstatusself(~storedbonus~); adjustrobotcounter(0); removestatusself(~storedbonus~[;] ALL);,,,,,,,
storedbonusupgraded,Stored_Bonus+,jackpot,Bonus Payout+ will trigger <value> time(s) next turn.,YES,NO,NO,NO,NO,,,,self.roll_jackpotbonus += getstatusself(~storedbonus~); self.roll_range += getstatusself(~storedbonus~) * 2; adjustrobotcounter(0); removestatusself(~storedbonus~[;] ALL);,,,,,,,
survivenextturn,Survive_Next_Turn,curse,Gain 1 survive next turn.,NO,NO,NO,NO,NO,,,,inflictself(~survive~[;]1); inflictself(~survivenomorehehe~[;]1); removestatusself(~survivenextturn~);,,,,,,,
placeholder,Stolen_Innate,star,(This should always be replaced! If you're reading this[;] it's a bug!),NO,NO,NO,NO,NO,var sD = switch target.innate[0]{ case ~weakfire~: ~You take double damage from [fire] fire damage and [fire] Burn.~; case ~weakice~: ~You take double damage from [ice] ice damage.~; case ~weakshock~: ~You take double damage from [shock] shock damage and [shock] Shocked?.~; case ~strongfire~: ~You take half damage from [fire] fire damage and [fire] Burn.~; case ~strongpoison~: ~You take half damage from [poison] poison.~; case ~immunestatus~: ~You can't be inflicted with [lock] locked and [ice] freeze.~; case ~goesfirst~: ~You go first during the start of this battle. So[;] really[;] nothing changes.~; case ~gaindice~: ~You gain an extra dice at the start of each turn.~; case ~vampire~: ~You can't be defeated without a Wooden Stake... which Drake doesn't have.~; default: ~You gain the effects of your enemy's stolen innate.~; } status.template.description = sD; var statuses = [~fire~[;] ~ice~[;] ~shock~[;] ~poison~[;] ~lock~[;] ~dice~]; for(i in 0...statuses.length){ if(sD.indexOf(statuses[i]) != -1){ status.symbol = statuses[i]; } } if(target.innate[0] == ~goesfirst~) status.symbol = ~dodge~;,,,,,,,,,,
jackpotshard,Jackpot_Shard,jackpotshard,4 Jackpot Shards combine into an automatic Autoroll.,YES,NO,NO,NO,NO,while(getstatusself(~jackpotshard~) >= 4) { removestatusself(~jackpotshard~[;] 4); inflictself(~manualroll~); },,,,,,,,,,
iceallnextturn,Frozen_all,ice,Freeze all your dice next turn.,NO,NO,NO,NO,NO,,,inflictself(~ice_all~); removestatusself(~iceallnextturn~);,,,,,,,,
icenextturn,Frozen,ice,Gain <value> freeze next turn.,YES,NO,NO,NO,NO,,,inflictself(~ice~[;] getstatusself(~icenextturn~)); removestatusself(~icenextturn~[;] ALL);,,,,,,,,
extrajackpotskill,Bonus_Slot,gold,Your jackpot has <value> extra options. Shouldn't show up! If it does[;] it's buggin... and that ain't thuggin...,YES,NO,NO,YES,NO,/* i might be descending into insanity */,,,,,,,,,,
virus,Virus,virus,Take <value> damage at the end of your turn if you triggered an error during it.,YES,NO,NO,NO,NO,,,,,,,if(self.roll_error){ attackself(getstatusself(~virus~)); sfxdamage(getstatusself(~virus~)); } /*A leftover thingy from when I wanted to add custom enemies to the game. This one ain't that great. Turns Slime into an unloseable fight.*/,,,,
bsodtriggered,ShouldntAppear!,virus,You know the gist. It's invisible[;] BITCH!!!! What're you poking around for[;] damn!!!!,NO,NO,YES,YES,NO,/*ok im sorry for swearing in the description that was very mean of me i won't do it again i prommy [heart]*/,,,,,,,,,,
bigberthavisual,Big_Bertha,star,Every jackpot skill has a 33% chance to be upgraded when rolled.,NO,NO,NO,NO,NO,,,,,,,,,,,
bsodvisual,BSOD,star,When you trigger an error[;] you can still use your jackpot skills.,NO,NO,NO,NO,NO,,,,,,,,,,,
bluedevilcredits,Credits,devilfire,The Blue Devil is a skill made by Jultima!,NO,NO,YES,NO,NO,,,,,,,,,,,
retriggerall,Retrigger_All,retrigger,Whenever you re-use an equipment[;] re-trigger it instead with the same dice.,NO,YES,NO,NO,NO,,,,,,,,,,,
retriggernext,Retrigger_Next,retrigger,Whenever you re-use an equipment[;] re-trigger it instead with the same dice. Unimplemented.,YES,YES,NO,NO,NO,,,,,,,,,,,
doublespookyfury,Spooky_Fury,fury,50% chance to use the next equipment twice[;]|lasts until something triggers it.,YES,YES,NO,YES,NO,,,,,,,,,,,
reequippolly,,recycle,Inflict this with [recycle] on x equips[;] like Pirate Hook.,NO,NO,NO,YES,NO,if((self.hasstatus(~curse~) && chance(Rules.curseodds))){ for(eq in self.equipment){ if(eq.slots.length > 0){ eq.addtag(~curseattract~); eq.removetag(~curseavoid~); } } } else{ if(!self.hasstatus(~reuseblock~)){ if(self.hasstatus(~retriggerall~) # self.hasstatus(~maroonall~)){ sfx(~_recycle~[;] 1); sfx(~_fury~[;] 1); inflictself(~doublespookyfury~); } else{ inflictself(~reequipnext~); sfx(~_recycle~[;]~~[;]0.2); } removestatusself(~reequippolly~[;] ALL); for(eq in self.equipment){ if(eq.slots.length > 0){ eq.addtag(~curseavoid~); eq.removetag(~curseattract~); } if(eq.hastag(~triggersonreuse~)){ eq.doequipmentaction(self[;] target[;] 1[;] [][;] 0.1[;] true[;] false[;] false); } }  removestatusself(~landlubbershack~[;] 1); self.setvar(~turnreusecount~[;] self.getvar(~turnreusecount~) + 1); self.setvar(~doublereusecount~[;] self.getvar(~turnreusecount~) * 2); } else{ removestatusself(~reuseblock~[;] 1); } },,,,,,,,,,
reequippolly@nouse,,,Inflict this when gaining re-uses from an equipment that |doesn't immediately use them. e.g. Hookshot. Unimplemented.,NO,NO,NO,YES,NO,if(self.hasstatus(~retriggerall~)){ inflictself(~retriggernext~); sfx(~_fury~); } else{ inflictself(~reequipnext~); sfx(~_recycle~[;]~~[;]0.2); } removestatusself(~reequippolly@nouse~[;] ALL);,,,,,,,,,,
retriggerpolly,,retrigger,Inflict this with [retrigger] on x equips[;] like the second half of Which Way[;] Captain?.,NO,NO,NO,YES,NO,if((self.hasstatus(~curse~) && chance(Rules.curseodds))){ for(eq in self.equipment){ if(eq.slots.length > 0){ eq.addtag(~curseattract~); eq.removetag(~curseavoid~); } } } else{ if(!self.hasstatus(~reuseblock~)){ if(self.hasstatus(~retriggerall~) # self.hasstatus(~maroonall~)){ inflictself(~reequipnext~); sfx(~_recycle~[;]~~[;]0.2); } else{ sfx(~_recycle~[;] 1); sfx(~_fury~[;] 1); inflictself(~doublespookyfury~); } removestatusself(~reequippolly~[;] ALL); for(eq in self.equipment){ if(eq.slots.length > 0){ eq.addtag(~curseavoid~); eq.removetag(~curseattract~); } if(eq.hastag(~triggersonreuse~)){ eq.doequipmentaction(self[;] target[;] 1[;] [][;] 0[;] true[;] false[;] false); } }  removestatusself(~landlubbershack~[;] 1); self.setvar(~turnreusecount~[;] self.getvar(~turnreusecount~) + 1); self.setvar(~doublereusecount~[;] self.getvar(~turnreusecount~) * 2); } else{ removestatusself(~reuseblock~[;] 1); } },,,,,,,,,,
maroonedchad,Marooned_Chad,retrigger,(Shouldn't appear. Ensures every equip retriggers on all values.),NO,NO,YES,YES,NO,for(eq in self.equipment){ eq.setvar(~redice~[;] [1[;]2[;]3[;]4[;]5[;]6]); },for(eq in self.equipment){ eq.setvar(~redice~[;] [1[;]2[;]3[;]4[;]5[;]6]); },,,for(eq in self.equipment){ eq.setvar(~redice~[;] [1[;]2[;]3[;]4[;]5[;]6]); },for(eq in self.equipment){ eq.setvar(~redice~[;] [1[;]2[;]3[;]4[;]5[;]6]); },,,,,
maroonall,Marooned_Chad,retrigger,Whenever you use an equipment[;] re-trigger it instead with the same dice.,NO,NO,NO,NO,NO,,,,,,,,,,,
recycleon1,Re-Use_On_1,reuseon1,All of your equipment [recycle] on 1.,NO,YES,NO,NO,NO,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(1) == -1){ arr.push(1); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [1]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(1) == -1){ arr.push(1); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [1]); } },,,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(1) == -1){ arr.push(1); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [1]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(1) == -1){ arr.push(1); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [1]); } },,,,,
recycleon2,Re-Use_On_2,reuseon2,All of your equipment [recycle] on 2.,NO,YES,NO,NO,NO,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(2) == -1){ arr.push(2); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [2]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(2) == -1){ arr.push(2); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [2]); } },,,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(2) == -1){ arr.push(2); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [2]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(2) == -1){ arr.push(2); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [2]); } },,,,,
recycleon3,Re-Use_On_3,reuseon3,All of your equipment [recycle] on 3.,NO,YES,NO,NO,NO,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(3) == -1){ arr.push(3); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [3]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(3) == -1){ arr.push(3); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [3]); } },,,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(3) == -1){ arr.push(3); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [3]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(3) == -1){ arr.push(3); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [3]); } },,,,,
recycleon4,Re-Use_On_4,reuseon4,All of your equipment [recycle] on 4.,NO,YES,NO,NO,NO,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(4) == -1){ arr.push(4); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [4]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(4) == -1){ arr.push(4); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [4]); } },,,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(4) == -1){ arr.push(4); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [4]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(4) == -1){ arr.push(4); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [4]); } },,,,,
recycleon5,Re-Use_On_5,reuseon5,All of your equipment [recycle] on 5.,NO,YES,NO,NO,NO,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(5) == -1){ arr.push(5); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [5]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(5) == -1){ arr.push(5); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [5]); } },,,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(5) == -1){ arr.push(5); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [5]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(5) == -1){ arr.push(5); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [5]); } },,,,,
recycleon6,Re-Use_On_6,reuseon6,All of your equipment [recycle] on 6.,NO,YES,NO,NO,NO,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(6) == -1){ arr.push(6); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [6]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(6) == -1){ arr.push(6); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [6]); } },,,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(6) == -1){ arr.push(6); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [6]); } },for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ if(arr.indexOf(6) == -1){ arr.push(6); eq.setvar(~redice~[;] arr); } } else { eq.setvar(~redice~[;] [6]); } },,,,,
reuseblock,Re-Unusable,reuseblock,The next <value> equipment you [recycle]re-use or [retrigger]re-trigger gets used normally instead.|(This gets removed at the end of your turn.),YES,YES,NO,NO,NO,,,,,,,,,,,
bluescorch,Faerie_Fire,devilfire,Burning dice cost [heart]<value> health more to extinguish this turn.,YES,YES,NO,NO,NO,,,Rules.burningdicecost += getstatusself(~bluescorch~); var act = new motion.actuators.SimpleActuator(null[;] 0.01[;] null); var s = new elements.DiceyScript(~for (dice in self.dicepool) {     if (dice.overlayimage == 'fire' && self.getstatus('bluescorch') > 0)     {self.setvar(\~blueact\~[;] act);         dice.overlayimage = 'hellfire';         var frame1 = new displayobjects.HaxegonSprite(0[;] 0[;] 'ui/dice/hellburn/flame20000'[;] 0[;] 0);         dice.graphic.overlayimage = frame1;         for (i in 0...17)         {             var val = 20000 + i + 1;             dice.graphic.overlayimage.addimageframe('ui/dice/hellburn/flame' + val);         }     } }~); s.set(~self~[;] self); s.set(~act~[;] act); act.onRepeat(s.execute[;] [self[;] target]); act._repeat = -1; act.move();,,,,,,,,Rules.burningdicecost -= getstatusself(~bluescorch~); trace(self.getvar(~blueact~)); self.getvar(~blueact~)._repeat = 0;
reuseroll,Re-Use_Roll,recycle,The next <value> dice you roll that can't trigger |a [recycle]re-use reroll into ones that can. (Unimplemented),NO,NO,NO,NO,NO,var s = new elements.Skill(~Against all odds_old~); var act = new motion.actuators.SimpleActuator(); /*rurd stands for ~re-use rerolled dice~*/ if(self.getvar(~rurd~) == 0){ self.setvar(~rurd~[;] []); } s.script = ~ var reusevals = []; for(eq in self.equipment){ if(eq.ready){ if(eq.getvar(\~redice\~).length > 0){ if(eq.remainingcountdown > 0 && eq.remainingcountdown < 7){ reusevals.push(eq.remainingcountdown); } else{ if(eq.getvar(\~redice\~)[0] < 7){ reusevals = reusevals.concat(eq.getvar(\~redice\~)); } } } if(eq.getvar(\~retdice\~).length > 0){ reusevals = reusevals.concat(eq.getvar(\~retdice\~)); } } } var canreroll = false; if(reusevals.length > 0){ canreroll = true; }  if(canreroll){ for(mydice in self.dicepool){ if(reusevals.indexOf(mydice.basevalue + mydice.modifier) == -1 && !mydice.intween() && self.getvar(\~rurd\~).indexOf(mydice) == -1){ mydice.animate(\~flashshake\~); mydice.animation[mydice.animation.length - 1].addcommand(\~textparticle\~[;] \~[recycle] Re-useable! [recycle]\~[;]\~0xffffff\~); mydice.basevalue = rand(reusevals); mydice.modifier = 0; var temparr = self.getvar(\~rurd\~); temparr.push(mydice); self.setvar(\~rurd\~[;] temparr); removestatusself(\~reuseroll\~[;] 1); } } } ~; act.onRepeat(s.execute[;] [self[;] target]); act._repeat = -1; act.move(); self.setvar(~reuserollact~[;] act);,,,,,,,self.getvar(~reuserollact~).repeat = 0;,,,self.getvar(~reuserollact~).repeat = 0;
golddisplay,Gold,gold,Has <value> gold.,YES,NO,NO,NO,NO,status._displayvalue = self.gold;,,,,status._displayvalue = self.gold;,,,,,,
vortex,Vortex,vortex,Whenever you create [vortex]10 vortexes[;] |you drain [heart]10 health from your enemy.,YES,NO,NO,NO,NO,while(getstatusself(~vortex~) >= 10) { removestatusself(~vortex~[;] 10); drain(10); sfx(~_drain~); },,,,,,,,,,
cpunerf,CPU_Down,dice,CPU is reduced by <value> for this turn.,YES,NO,NO,NO,NO,,,self.roll_target -= getstatusself(~cpunerf~);,,,,self.roll_target += getstatusself(~cpunerf~); removestatusself(~cpunerf~[;] ALL);,,,,
smorify,Smorify,smore,You're a smore[;] now.,NO,NO,NO,NO,NO,target.vfxoffset.y -= target.graphic.get_height() / 5; sfx(~_thinghappens~); target.symbolparticle(~beartransform~); var delayedcheck = new motion.actuators.SimpleActuator(null[;] 0.3[;] null); var s = new elements.Skill(~Against all odds_old~); s.script = ~target.graphicyoff += target.graphic.get_height() / 2;target.graphic.set_height(target.graphic.get_height() / 5);~; delayedcheck.onComplete(s.execute[;] [self[;]target]); delayedcheck.move(); /* Lmao. */,,,,,,,,,,target.vfxoffset.y += target.graphic.get_height(); sfx(~_thinghappens~); target.symbolparticle(~beartransform~); var delayedcheck = new motion.actuators.SimpleActuator(null[;] 0.3[;] null); var s = new elements.Skill(~Against all odds_old~); s.script = ~target.graphic.set_height(target.graphic.get_height() * 5);target.graphicyoff -= target.graphic.get_height() / 2;~; delayedcheck.onComplete(s.execute[;] [self[;]target]); delayedcheck.move();
landlubbershack,Landlubber's_Hack,reuseon3,The next <value> equipment you use can [reuseon1] [reuseon2] [reuseon3][].,YES,YES,NO,NO,NO,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ arr = arr.concat([1[;]2[;]3]); eq.setvar(~redice~[;] arr); } else { eq.setvar(~redice~[;] [1[;]2[;]3]); } },,,,,for(eq in self.equipment){ var arr = eq.getvar(~redice~); if(arr.length > 0){ arr = arr.concat([1[;]2[;]3]); eq.setvar(~redice~[;] arr); } else { eq.setvar(~redice~[;] [1[;]2[;]3]); } },,,,,for(eq in self.equipment){ eq.setvar(~redice~[;] eq.getvar(~ogredice~)); }
limittracker,Pirate_Is_The_Roaring_Knight???,star,keeps track of the player's limit charge for glowing cutlass.,NO,NO,NO,YES,NO,self.setvar(~limitcharge~[;] self.limitvalue);,self.setvar(~limitcharge~[;] self.limitvalue);,,,,,,,,self.setvar(~limitcharge~[;] self.limitvalue + 1);,
jayinnate,,,(Shouldn't show up[;] increases burn costs every turn and updates innate to show burn cost dynamically.),NO,NO,NO,YES,NO,self.innate = [~strongfire~[;] ~ups [fire] cost by 1/turn ([fire]~ + Rules.burningdicecost + ~[])~];,,,,self.innate = [~strongfire~[;] ~ups [fire] cost by 1/turn ([fire]~ + Rules.burningdicecost + ~[])~];,,Rules.burningdicecost += 1; self.innate = [~strongfire~[;] ~ups [fire] cost by 1/turn ([fire]~ + Rules.burningdicecost + ~[])~]; target.symbolparticle(~fire~); target.textparticle(~Burn cost up!~); sfx(~_fire~);,,,,
countdownrediceupdate,Shla_Boing_Boing,cog,(Shouldn't appear. Makes sure specific countdown equipment can get properly re-used.),NO,NO,NO,YES,NO,,,,,,if(e.name == ~Reinforced Leg~){ if(e.dicehistory.length > 0){ var resultval = e.remainingcountdown - e.reducecountdownby - (e.dicehistory[e.dicehistory.length - 1].basevalue + e.dicehistory[e.dicehistory.length - 1].modifier); if(resultval > 0){ var redicelist = []; for(i in 1...7){ if(i > resultval){ redicelist.push(i); } } e.setvar(~redice~[;] redicelist); e.setvar(~ogredice~[;] redicelist); } } } else if(e.name == ~Charge 'N Load~){ if(e.dicehistory.length > 0){ var resultval = e.remainingcountdown - e.reducecountdownby - (e.dicehistory[e.dicehistory.length - 1].basevalue + e.dicehistory[e.dicehistory.length - 1].modifier); if(resultval > 0){ e.setvar(~redice~[;] [resultval]); e.setvar(~ogredice~[;] [resultval]); } } },,,,,
luckysevensslot,,jackpot,Keeps track of the Lucky Sevens' Slot equipment. (Shouldn't show up.),NO,YES,NO,YES,NO,var s = new elements.DiceyScript(~ var options = []; for(eq in self.equipment) {  if(eq.name == 'Slot' && eq.finalpos != null) { options.push(eq); } } if(options.length > 0) {  for(eq in options) { if(!eq.hastag('slotpicked')){ if(eq.x == eq.finalpos.x && eq.y == eq.finalpos.y){ eq.addtag('slotpicked'); sfx('jackpot_reducecounter'); screenshake(); } } if(!eq.availablethisturn) eq.changeslots(['MAX2']); if((eq.x != eq.finalpos.x # eq.y != eq.finalpos.y) && eq.ready && eq.availablethisturn) { var vals = ['REQUIRE1'[;] 'REQUIRE2'[;] 'REQUIRE3'[;] 'REQUIRE4'[;] 'REQUIRE5'[;] 'REQUIRE6']; vals.remove(eq.slots[0]);  var picked = rand(vals); eq.changeslots([picked]); } } } ~); var act = new motion.actuators.SimpleActuator(null[;] 0.07[;] null); act.onRepeat(s.execute[;] [self[;] target]); act._repeat = -1; s.set('self'[;] self); s.set('target'[;] target); s.set('rand'[;] rand); s.set('sfx'[;] sfx); s.set('screenshake'[;] screenshake); act.move(); self.setvar('luckysevenact'[;] act);,,,,,,,,,,self.getvar(~luckysevenact~)._repeat = 0;
