ID,Character,Level,Episode Name,Description,Rules Description,Equipment,Layout,Skillcard,Limit,Weakened Limit,Dice,Health,Generator,Super Level 2,Super Level 3,Super Level 4,Super Level 5,Cutscene,Script: Define Level Up Rewards,Script: Start Game,Script: After Level Up,Script: Change Floor,Script: Before Start Turn,Script: On Start Turn,Script: End Turn,Script: Start Combat,Script: After Combat
diceydungeons_robot_1,Robot,1,Let's Go Gambling!,You probably shouldn't see this! Unless you're diving through files[;] of course.|If you are[;] hi! Hello!! Hiiii! Omg hi!! Hru!!! Hru doing!!!,Every turn[;] your jackpot abilities are randomized.|Also this shouldn't show up[;] either[;] I don't think?,Rebet Blade|Pea Shooter,EQUIPMENT,Robot Calculate,Bonus Payout,Lucky Shot,0,24,robot_normal,0,0,0,0,robot1,leveluprewards(2[;] ~CPU:2~); leveluprewards(3[;] ~~[;] [~Equipment:Inhibited Blade~[;]~Equipment:Jacked Switch~[;] ~Upgrade~]); leveluprewards(4[;] ~CPU:2~); leveluprewards(5[;] ~~[;] [~Equipment:Big Bertha~[;] ~Equipment:BSOD~]); leveluprewards(6[;] ~CPU:2~);,Rules.includerareenemies = false; Rules.altequipmentname = ~Permanent Buff~; var excludedenemies = getcolumn(loaddata(~diceydungeons/excludedenemies~)[;] ~robot1~); excludedenemies.push(~Copycat~); Rules.excludeenemies(excludedenemies); self.usecpuinsteadofdice = true; Rules.limitbreakcost = 8; var lmao = new displayobjects.HaxegonSprite(0[;]0[;]~file of great importance (DO NOT TOUCH)~[;]0[;]0); var delayedcheck = new motion.actuators.SimpleActuator(null[;] 0.01[;] null); var s = new elements.Skill(~Against all odds_old~); s.script = ~Rules.rulescreen(\~skillsatlevel\~ + self.level); Rules.overworldbutton_name = \~Rollable Skills\~; Rules.overworldbutton_action = \~rulescreen\~;~; delayedcheck.onComplete(s.execute[;] [self[;]target]); delayedcheck.move();,var delayedcheck = new motion.actuators.SimpleActuator(null[;] 1[;] null); var s = new elements.Skill(~Against all odds_old~); s.script = ~ for(eq in getbackpackcontents())   {    if(eq.name == 'Big Bertha')   {     self.setvar('skillscanbeupgraded'[;] true);    }     if(eq.name == 'BSOD') { self.setvar('jackpotonerror'[;] true); } }   for(eq in self.equipment)  {   if(eq.name == 'Big Bertha')   {   self.setvar('skillscanbeupgraded'[;] true);  }   if(eq.name == 'BSOD') { self.setvar('jackpotonerror'[;] true); } }~; delayedcheck.onComplete(s.execute[;] [self[;]target]); delayedcheck.move(); Rules.rulescreen(~skillsatlevel~ + self.level); Rules.overworldbutton_name = ~Rollable Skills~; Rules.overworldbutton_action = ~rulescreen~;,self.setvar(~FloorNumber~[;]self.getvar(~FloorNumber~) + 1);,if(self.getskillcard().skills.length > 0){ self.getskillcard().skills = [self.getskillcard().skills[0]]; } runscript(~jackpotofalltrades/rerolljackpot~); /*Resetting skillcard stuffs[;] fixes Bonus Slot and BSOD.*/ self.getskillcard().height = 1080;,/*Code below fixes Limit Break*/ if(self.getvar(~unlimitcards~).length > 0){ var limitcards = self.getvar(~unlimitcards~); var limitcardslots = self.getvar(~unlimitslots~); for(i in 0...self.getvar(~unlimitcards~).length){ self.getvar(~unlimitcards~)[i].changeslots(self.getvar(~unlimitslots~)[i]); self.getvar(~unlimitcards~)[i].animate(~slotschanged~); } self.setvar(~unlimitcards~[;] []); self.setvar(~unlimitslots~[;] []); }    self.setvar(~dothelimitbreak~[;]0); self.setvar(~previousroundplayerhp~[;]self.getvar(~currentroundplayerhp~)); self.setvar(~previousroundenemyhp~[;]self.getvar(~currentroundenemyhp~)); self.setvar(~currentroundplayerhp~[;]self.hp); self.setvar(~currentroundenemyhp~[;]target.hp);,self.setvar(~firstturnpassed~[;]true);,/*if(self.getvar(~dicefubny~) == 0){ inflictself(~Dice Big~); }*/ self.setvar(~firstturnpassed~[;]false); self.setvar(~previousroundenemyhp~[;] target.hp); self.setvar(~previousroundplayerhp~[;] 0); runscript(~jackpotofalltrades/illegaldice~); runscript(~jackpotofalltrades/checkforbonusslot~); /*BSOD CODE*/ if(self.getvar(~jackpotonerror~)){ runscript(~jackpotofalltrades/errorcheck~); inflictself(~bsodvisual~); } if(self.getvar(~skillscanbeupgraded~)){ inflictself(~bigberthavisual~); },self.changelimitbreak(~Bonus Payout~); /*Code below fixes Limit Break*/ if(self.getvar(~unlimitcards~).length > 0){ var limitcards = self.getvar(~unlimitcards~); var limitcardslots = self.getvar(~unlimitslots~); for(i in 0...self.getvar(~unlimitcards~).length){ self.getvar(~unlimitcards~)[i].changeslots(self.getvar(~unlimitslots~)[i]); self.getvar(~unlimitcards~)[i].animate(~slotschanged~); } self.setvar(~unlimitcards~[;] []); self.setvar(~unlimitslots~[;] []); }
pollymod_pirate_1,Pirate,1,Hook[;] Line and Sinker!,,,Pirate Hook|Keelhaul|Pick Leg|Landlubber's Hack_upgraded,EQUIPMENT,Skillcard Fix,Play Hooky,Hook,2,24,pirate_normal,0,0,0,0,,leveluprewards(2[;] ~Dice~); leveluprewards(3[;] ~~[;] [~Equipment:Spiked Shield~[;]~Equipment:Boomerang~]); leveluprewards(4[;] ~Dice~); leveluprewards(5[;] ~~[;] [~Equipment:Shield Bash~[;] ~Upgrade~]); leveluprewards(6[;] ~Dice~);,Rules.excludeenemies([~Pirate~]); Rules.limitbreakcost = 6;,,,/* MAYBE i'll figure this out again because i do like how it looks. i don't know how to implement it perfectly though without a lot of effort*/ /*var delayedcheck = new motion.actuators.SimpleActuator(null[;] 0.01[;] null); var s = new elements.Skill(~Against all odds_old~); s.script = ~ for(eq in self.equipment){ if(eq.hastag('recycles')){ eq.setvar('fury'[;] false); eq.displayname = eq.name + ' [recycle]' + eq.getvar('redice')[0]; trace(eq.fulldescription); trace(eq.fulldescription.split('[newline]')); var newdesc = eq.fulldescription.split('[newline]'); newdesc.pop(); var newdesctext = ''; for(i in 0...newdesc.length){ if(i != 0) newdesctext += '[newline]'; newdesctext += newdesc[i]; } eq.fulldescription = newdesctext; } }~; delayedcheck.onComplete(s.execute[;] [self[;]target]); delayedcheck.move(); */,,,for(eq in self.equipment){ eq.setvar(~ogdescription~[;] eq.fulldescription); },for(eq in self.equipment){ if(eq.getvar(~ogdescription~) != 0) eq.fulldescription = eq.getvar(~ogdescription~); }
